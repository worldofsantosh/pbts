PDX - ORD 26 
ORD - ROC 15
ROC - DCA 10
ROC - ATL 22
ROC - MCO 24
DCA - LAX 36
DCA - SFO 25
SFO - ORD 37
LAX - SFO 10

Create a class, RouteNetwork, and add a main method that makes a graph to represent the network of airports shown in the image above.

a. Each airport is a vertex. The airport code is a string, e.g. "ROC".

b. The weight of each edge is an amount in tens of dollars, e.g. 15 = $150.

3. Implement Dijkstra’s Algorithm as described in class. Modify the main method in your RouteNetwork class to:

a. Prompt the user to enter two airport codes, e.g. DCA and ORD

b. Print the lowest cost path between the two airports as determined by Dijkstra’s Algorithm, e.g. "DCA ROC ORD, 250 dollars."


import java.util.*;

class Edge {
    String destination;
    int weight;

    public Edge(String destination, int weight) {
        this.destination = destination;
        this.weight = weight;
    }
}

class Graph {
    private Map<String, List<Edge>> adjacencyList;

    public Graph() {
        adjacencyList = new HashMap<>();
    }

    public void addEdge(String source, String destination, int weight) {
        adjacencyList.putIfAbsent(source, new ArrayList<>());
        adjacencyList.get(source).add(new Edge(destination, weight));

        // Since the network is undirected, add the edge in both directions
        adjacencyList.putIfAbsent(destination, new ArrayList<>());
        adjacencyList.get(destination).add(new Edge(source, weight));
    }

    public List<String> findShortestPath(String start, String end) {
        // Dijkstra's Algorithm implementation

        // Distance map to store the shortest distance to each airport
        Map<String, Integer> distances = new HashMap<>();
        Map<String, String> previous = new HashMap<>();

        // Initialize distances to infinity
        for (String airport : adjacencyList.keySet()) {
            distances.put(airport, Integer.MAX_VALUE);
        }
        distances.put(start, 0);

        // Priority queue to select the airport with the smallest distance
        PriorityQueue<String> queue = new PriorityQueue<>(Comparator.comparingInt(distances::get));
        queue.add(start);

        while (!queue.isEmpty()) {
            String current = queue.poll();

            if (current.equals(end)) {
                break;
            }

            for (Edge edge : adjacencyList.getOrDefault(current, new ArrayList<>())) {
                String neighbor = edge.destination;
                int newDist = distances.get(current) + edge.weight;
                if (newDist < distances.get(neighbor)) {
                    distances.put(neighbor, newDist);
                    previous.put(neighbor, current);
                    queue.add(neighbor);
                }
            }
        }

        // Reconstruct the path
        List<String> path = new LinkedList<>();
        String current = end;

        if (!distances.containsKey(end) || distances.get(end) == Integer.MAX_VALUE) {
            // No path found
            return null;
        }

        while (current != null) {
            path.add(0, current);
            current = previous.get(current);
        }

        return path;
    }

    public int getPathCost(List<String> path) {
        int totalCost = 0;
        for (int i = 0; i < path.size() - 1; i++) {
            String source = path.get(i);
            String destination = path.get(i + 1);
            // Find the weight between source and destination
            for (Edge edge : adjacencyList.get(source)) {
                if (edge.destination.equals(destination)) {
                    totalCost += edge.weight;
                    break;
                }
            }
        }
        return totalCost;
    }
}

public class RouteNetwork {
    public static void main(String[] args) {
        Graph graph = new Graph();

        // Build the graph with the provided data
        graph.addEdge("PDX", "ORD", 26);
        graph.addEdge("ORD", "ROC", 15);
        graph.addEdge("ROC", "DCA", 10);
        graph.addEdge("ROC", "ATL", 22);
        graph.addEdge("ROC", "MCO", 24);
        graph.addEdge("DCA", "LAX", 36);
        graph.addEdge("DCA", "SFO", 25);
        graph.addEdge("SFO", "ORD", 37);
        graph.addEdge("LAX", "SFO", 10);

        // Prompt user for input
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter start airport code: ");
        String start = scanner.nextLine().trim().toUpperCase();
        System.out.print("Enter destination airport code: ");
        String end = scanner.nextLine().trim().toUpperCase();
        scanner.close();

        // Find and display the shortest path
        List<String> path = graph.findShortestPath(start, end);

        if (path == null) {
            System.out.println("No path found from " + start + " to " + end + ".");
        } else {
            int cost = graph.getPathCost(path) * 10; // Convert to dollars
            System.out.print("Shortest path: ");
            for (int i = 0; i < path.size(); i++) {
                System.out.print(path.get(i));
                if (i != path.size() - 1) {
                    System.out.print(" ");
                }
            }
            System.out.println(", " + cost + " dollars.");
        }
    }
}

