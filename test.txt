2.
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class Hand implements Iterable<PlayingCard> {
    private Set<PlayingCard> cards;

    // Constructor to initialize an empty Hand
    public Hand() {
        cards = new HashSet<>();
    }

    // Adds a card to the hand. Returns true if the card was added, false if it was already present.
    public boolean addCard(PlayingCard card) {
        return cards.add(card);
    }

    // Removes a card from the hand.
    public void removeCard(PlayingCard card) {
        cards.remove(card);
    }

    // Returns the size of the hand.
    public int size() {
        return cards.size();
    }

    // Provides an iterator for the cards in the hand.
    @Override
    public Iterator<PlayingCard> iterator() {
        return cards.iterator();
    }
}

3.
import java.util.*;
import practicum.PlayingCard;
import practicum.PlayingCard.Rank;
import practicum.PlayingCard.Suit;

public class CardOrganizer {

    public Map<Suit, List<PlayingCard>> cardsBySuit(Deck deck) {
        Map<Suit, List<PlayingCard>> suitMap = new HashMap<>();
        for (PlayingCard card : deck) {
            suitMap.computeIfAbsent(card.getSuit(), k -> new ArrayList<>()).add(card);
        }
        return suitMap;
    }

    public Map<Rank, List<PlayingCard>> cardsByRank(Deck deck) {
        Map<Rank, List<PlayingCard>> rankMap = new HashMap<>();
        for (PlayingCard card : deck) {
            rankMap.computeIfAbsent(card.getRank(), k -> new ArrayList<>()).add(card);
        }
        return rankMap;
    }
}


4.import java.util.*;
import practicum.PlayingCard;
import practicum.PlayingCard.Rank;
import practicum.PlayingCard.Suit;

public class Deck implements Iterable<PlayingCard> {
    private List<PlayingCard> cards;

    public Deck() {
        cards = new ArrayList<>();
        shuffle();
    }

    public void shuffle() {
        cards.clear();
        for (Suit suit : Suit.values()) {
            for (Rank rank : Rank.values()) {
                cards.add(new PlayingCard(rank, suit));
            }
        }
        Collections.shuffle(cards);
    }

    public PlayingCard draw() {
        if (cards.isEmpty()) {
            throw new NoSuchElementException("No cards left in the deck");
        }
        return cards.remove(cards.size() - 1); // O(1) time
    }

    public int remaining() {
        return cards.size();
    }

    @Override
    public Iterator<PlayingCard> iterator() {
        return cards.iterator();
    }
}

5.
1. Modifying PlayingCard Class for Natural Ordering:
public class PlayingCard implements Comparable<PlayingCard> {
    private Suit suit;
    private Rank rank;

    // Constructor to initialize a card with a suit and a rank
    public PlayingCard(Suit suit, Rank rank) {
        this.suit = suit;
        this.rank = rank;
    }

    // Getters for suit and rank
    public Suit getSuit() {
        return suit;
    }

    public Rank getRank() {
        return rank;
    }

    // Implement the compareTo method to define natural ordering
    @Override
    public int compareTo(PlayingCard other) {
        // First compare by suit
        int suitComparison = this.suit.compareTo(other.suit);
        if (suitComparison != 0) {
            return suitComparison;
        }
        // If suits are the same, compare by rank
        return this.rank.compareTo(other.rank);
    }

    // Equals and hashCode methods (important for HashSet/HashMap usage)
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        PlayingCard that = (PlayingCard) obj;
        return suit == that.suit && rank == that.rank;
    }

    @Override
    public int hashCode() {
        return Objects.hash(suit, rank);
    }

    // Override toString for easy printing (optional)
    @Override
    public String toString() {
        return rank + " of " + suit;
    }
}

2.Adding sort() Method to the Deck Class:
import java.util.*;

public class Deck implements Iterable<PlayingCard> {
    private List<PlayingCard> cards;

    // Constructor to create a new Deck
    public Deck() {
        cards = new ArrayList<>();
        shuffle();  // Shuffle the deck initially to fill it with cards
    }

    // Shuffle method to fill the deck with 52 cards and randomize the order
    public void shuffle() {
        cards.clear();
        for (Suit suit : Suit.values()) {
            for (Rank rank : Rank.values()) {
                cards.add(new PlayingCard(suit, rank));
            }
        }
        Collections.shuffle(cards);
    }

    // Sort method to sort the cards in the deck based on the natural ordering defined in PlayingCard
    public void sort() {
        Collections.sort(cards);
    }

    // Iterator implementation to iterate over the cards in the deck
    @Override
    public Iterator<PlayingCard> iterator() {
        return cards.iterator();
    }
}







